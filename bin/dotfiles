#!/usr/bin/env bash
set -e  # exit on first error

DOTFILES=~/.dotfiles

# Source utility functions if doesn't exist
if [[ ! $(type -t 'cmd_exists') ]]; then
    if [[ -f "$DOTFILES/source/01_functions.sh" ]]; then
        source "$DOTFILES/source/01_functions.sh"
    else
        eval "$(curl -fsSL 'https://raw.githubusercontent.com/clns/dotfiles/master/source/01_functions.sh')"
    fi
fi

#
# Handle help
#
OPTIONS=(
"-h" "Display this info"
"-u" "Upgrade installed packages (currently only Homebrew, TODO: Ubuntu)"
"-q" "Quick mode on (skip some time consuming operations like 'brew update'"
"-y" "Answer YES to all questions"
)
installs=()
if [[ -d $DOTFILES ]]; then
    for inst in $DOTFILES/install/*; do
        inst=$(basename "$inst"); installs+=("${inst%.*}")
    done
fi
function help() {
cat <<HELP
Usage: $(basename "$0") [options] <command> [...args]

Commands:
help      Open README in browser
link      Link step
copy      Copy step
install   Install step; if additional args are given, it will install only those installs; 
          possible args: $(echo "${installs[@]}")

Options:
$(echo_flags "\t" "${OPTIONS[@]}")

Note: Is recommended to run the command as 'sudo' to allow the scripts
to configure stuff correctly (eg. PostgreSQL will set timezone=UTC).

HELP
exit 0
}
parse_arguments "${#OPTIONS[@]}" "${OPTIONS[@]}" $@

# Show help
has_flag '-h' && help
has_param 'help' && open https://github.com/clns/dotfiles/blob/master/README.md && exit 0

#
# Functions
#

# Copy files.
function copy_header() { log_header "Copying files into home directory"; }
function copy_test() {
    if [[ -e "$2" && ! "$(cmp "$1" "$2" 2> /dev/null)" ]]; then
        echo "same file"
    elif [[ "$1" -ot "$2" ]]; then
        echo "destination file newer"
    fi
    return 0
}
function copy_do() {
    echo "Copying ~/$1."
    cp "$2" ~/
}
function copy_postprocess() {
    if [[ $(basename $1) == ".gitconfig" ]]; then
        log_arrow "Enter the email address to use in ~/.gitconfig:"
        read -p ""
        sed -i -e "s/{EMAIL}/$REPLY/" $1
    fi
}

# Link files.
function link_header() { log_header "Linking files into home directory"; }
function link_test() {
    [[ "$1" -ef "$2" ]] && echo "same file"
    return 0
}
function link_do() {
    echo "Linking ~/$1"
    ln -sf ${2#$HOME/} ~/
}

# Process files
function processDir() {
    local base ext dest skip
    local files=($DOTFILES/$1/*)
    # No files? abort.
    if (( ${#files[@]} == 0 )); then return; fi
    # Run _header function only if declared
    [[ $(declare -f $1_header) ]] && $1_header
    for file in "${files[@]}"; do
        base="$(basename $file)"
        ext="${file##*.}"
        if [[ $ext == 'swp' ]]; then
            continue # skip Vim swap files
        fi
        dest="$HOME/$base"
        # Run _test function only if declared
        if [[ $(declare -f "$1_test") ]]; then
            # If _test function returns a string, skip file and print that message.
            skip="$("$1_test" "$file" "$dest")"
            if [[ "$skip" ]]; then
                echo "Skipping $dest, $skip"
                continue
            fi
            # If destination file already exists, back it up.
            if [[ -e "$dest" ]]; then
                # Set backup flag so we can print a message at the end
                backup=1
                # Create backup dir if doesn't already exist
                [[ -e $backup_dir ]] || mkdir -p $backup_dir
                # Backup file / link / whatever
                mv $dest $backup_dir
            fi
        fi
        # Actually process it
        $1_do $base $file
        # Do any post-processing
        [[ $(declare -f "$1_postprocess") ]] && $1_postprocess $dest
    done
}

#
# Do some stuff
#

# If git is not installed, install it (Ubuntu only since OS X has it installed by default)
if ! cmd_exists 'git' && is_ubuntu; then
    log_header "Installing git"
    sudo add-apt-repository -y ppa:git-core/ppa # Git repository
    sudo apt-get update
    sudo apt-get install -y git
fi

# Clone the repo or update if already cloned
if [[ ! -d $DOTFILES ]]; then
    # $DOTFILES directory doesn't exist, clone it
    git clone https://github.com/clns/dotfiles $DOTFILES
    cd $DOTFILES
else
    cd $DOTFILES
    if ! has_flag '-q'; then
        git pull
        git submodule update --init --recursive
    fi
fi

# If no command was used (eg. the first run from GitHub)
if [[ ${#PARAMS[@]} == 0 ]]; then
    echo "Run 'dotfiles <command>' to configure further, or 'dotfiles -h' for help."
fi

# Tweak file globbing.
# http://unix.stackexchange.com/a/162589
shopt -s dotglob
shopt -s nullglob

# If backups are needed, this is where they'll go.
backup_dir="$DOTFILES/backups/$(date "+%Y_%m_%d-%H_%M_%S")/"
backup=

# Process the files
if has_param 'copy'; then processDir "copy"; fi
if has_param 'link'; then processDir "link"; fi

# Alert if backups were made.
if [[ "$backup" ]]; then
    log_arrow "Backups were moved to ~/${backup_dir#$HOME/}"
fi

# Run installs
if has_param 'install'; then
    requirements=(brew)
    development=(node go postgresql macvim vim fonts)
    if [[ ${#PARAMS[@]} > 1 ]]; then
        all_instals=("${PARAMS[@]:1}")
    else
        all_instals=("${requirements[*]}" "${development[*]}")
    fi
    for install in ${all_instals[@]}; do
        source "install/${install}.sh"
    done
fi

source "link/.bashrc"
