#!/bin/sh

help() {
cat <<HELP
Usage:
 git commit-msg [<options>] [<commit-hash(es)> or <revision-range>]

Options:
 -g <no>    Filter commits with subject greater than <no> chars;
            any arguments will be ignored if this is used
 -f         The format to send to git-show for displaying commits;
            ignored if -e is used
 -e         Edit the commit message

Examples:
 git commit-msg -g 50
 git commit-msg -g 50 -f '--oneline' | awk '{ printf \$0 " "; \$1=""; print "(" length(\$0) ")" }'
 git commit-msg -c '39ae4f6 084d119'
 git commit-msg -c 'HEAD~2..'
 git commit-msg -c "\$(git log --pretty='%h' -E --grep='Make' --branches)"

 * All examples accept the -e option to edit the filtered commits.

Notes:
 Editing a commit message WILL CHANGE THE COMMIT HASH for that commit and
 all subsequent commits. For this reason you should only change commits
 that exist locally and were never pushed to a remote server.

Revision range:
 - single commit: <rev>^!, e.g. HEAD^! 55152c7^!
 See http://git-scm.com/docs/gitrevisions for more details.

HELP
}

if [ "$#" = "0" ]; then help; exit 0; fi

git_editor() {
	if test -z "${GIT_EDITOR:+set}"
	then
		GIT_EDITOR="$(git var GIT_EDITOR)" || return $?
	fi
	eval "$GIT_EDITOR" '"$@"'
}

cmd=
format=
tmp_dir=
while getopts "g:c:f:e" opt; do
    case $opt in
        g)
            cmd="git log --branches -E --grep='^.{$OPTARG,}' --pretty='%H %s' \
| awk '{h=\$1; \$1=\"\"; if (length(\$0)>$OPTARG) print h }'"
            ;;
        e)
            tmp_dir=$(mktemp -d 2>/dev/null || \
                mktemp -d -t 'commit-msg-edit' 2>/dev/null || \
                (dir="/tmp/commit-msg-$$"; mkdir -p "$dir" && echo "$dir"))
            if [ "$?" != "0" ] || [ ! -d "$tmp_dir" ]; then
                echo "Cannot create tmp dir" >&2; exit 1
            fi
            ;;
        c)
            # not used anymore, give this as argument(s)
            cmd="git show -s --format='%H %at' $OPTARG | sort -k2 -g -r | cut -f 1 -d ' '"
            ;;
        f)
            format="$OPTARG"
            ;;
        \?) help >&2 ; exit 1 ;;
    esac
done
shift $((OPTIND-1))

if [ -z "$cmd" ]; then
    cmd="git show -s --format='%H %at' $@ | sort -k2 -g | cut -f 1 -d ' '"
fi

if [ "$tmp_dir" ]; then # it's an edit
    for sha in $(eval "$cmd"); do
        file="$tmp_dir/$sha"
        git show -s --format='%B' $sha > $file
        echo "# Please enter the new commit message. Lines starting with '#'
# will be ignored, and an empty message aborts the edit.
# Everything below this line will be ignored. Do not remove this comment!
" >> $file
        git show \
            --format="commit %h%nAuthor: %an <%ae>%nDate:   %ad%nFound in: \
$(git branch --contains $sha | awk '{printf $0 "  "}')" \
            --stat $sha >> $file
        git_editor "$file"

        if [ "$?" != "0" ]; then rm -rf "$tmp_dir"; echo "Failed to edit file" >&2; exit 1; fi
        echo "$(awk '/^#/ { exit } { print }' $file)" > $file
        if [ -z "$(cat $file)" ]; then
            echo "Aborting edit due to empty commit message."
            exit 0
        fi
        if [ -z "$oldest_sha"]; then oldest_sha=$sha; fi
    done

    # Change commit messages starting from the oldest commit
    # and use all available branches
    git filter-branch -f --msg-filter 'dir='"$tmp_dir"'
file="$dir/$GIT_COMMIT";
if [ -e "$file" ]; then
    cat "$file";
else
    cat;
fi' -- $oldest_sha^.. --branches

    rm -rf "$tmp_dir"
else
    what="$(eval $cmd)"
    if [ "$what" ]; then
        git show -s $format $(eval "$cmd")
    fi
fi
